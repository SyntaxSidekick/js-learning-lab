{
  "meta": {
    "version": "2.0",
    "lastUpdated": "2025-11-04",
    "totalQuestions": 100,
    "categories": 15,
    "difficultyLevels": [
      "beginner",
      "intermediate",
      "advanced"
    ],
    "questionTypes": [
      "output",
      "concept",
      "debugging",
      "completion"
    ]
  },
  "categories": [
    {
      "id": "arrays",
      "name": "Arrays & Methods",
      "description": "Array manipulation, methods, and advanced techniques",
      "color": "#FF6B6B"
    },
    {
      "id": "variables",
      "name": "Variables & Data Types",
      "description": "Variable declarations, hoisting, scoping, and data types",
      "color": "#4CAF50"
    },
    {
      "id": "functions",
      "name": "Functions",
      "description": "Function declarations, expressions, arrow functions, and scope",
      "color": "#2196F3"
    },
    {
      "id": "objects",
      "name": "Objects & Properties",
      "description": "Object creation, manipulation, and property access",
      "color": "#FF9800"
    },
    {
      "id": "closures",
      "name": "Closures",
      "description": "Closure concepts, lexical scoping, and practical applications",
      "color": "#9C27B0"
    },
    {
      "id": "promises",
      "name": "Promises & Async",
      "description": "Asynchronous JavaScript, promises, async/await, and event loop",
      "color": "#F44336"
    },
    {
      "id": "prototypes",
      "name": "Prototypes & Classes",
      "description": "Prototype chain, inheritance, and ES6 classes",
      "color": "#607D8B"
    },
    {
      "id": "dom",
      "name": "DOM Manipulation",
      "description": "Document Object Model, events, and browser APIs",
      "color": "#795548"
    },
    {
      "id": "es6",
      "name": "ES6+ Features",
      "description": "Modern JavaScript features, destructuring, modules, and more",
      "color": "#3F51B5"
    },
    {
      "id": "operators",
      "name": "Operators & Expressions",
      "description": "Arithmetic, logical, comparison, and special operators",
      "color": "#009688"
    },
    {
      "id": "loops",
      "name": "Loops & Iteration",
      "description": "For loops, while loops, forEach, map, filter, and reduce",
      "color": "#CDDC39"
    },
    {
      "id": "strings",
      "name": "Strings & RegEx",
      "description": "String manipulation, template literals, and regular expressions",
      "color": "#E91E63"
    },
    {
      "id": "error-handling",
      "name": "Error Handling",
      "description": "Try-catch, error types, and debugging techniques",
      "color": "#FF5722"
    },
    {
      "id": "performance",
      "name": "Performance & Optimization",
      "description": "Memory management, performance optimization, and best practices",
      "color": "#8BC34A"
    },
    {
      "id": "advanced",
      "name": "Advanced Concepts",
      "description": "Complex patterns, design principles, and advanced JavaScript features",
      "color": "#673AB7"
    }
  ],
  "questions": [
    {
      "id": 1,
      "category": "arrays",
      "difficulty": "beginner",
      "type": "output",
      "title": "Array Push Method",
      "question": "What will be the output of the following code?",
      "code": "const arr = [1, 2, 3];\nconst result = arr.push(4);\nconsole.log(result);\nconsole.log(arr);",
      "options": [
        "4, [1, 2, 3, 4]",
        "[1, 2, 3, 4], 4",
        "4, [1, 2, 3]",
        "[1, 2, 3, 4], [1, 2, 3, 4]"
      ],
      "correctAnswer": 0,
      "explanation": "Array.push() returns the new length of the array after adding elements. The original array is modified.",
      "hints": [
        "push() returns the new length",
        "push() modifies the original array"
      ],
      "tags": [
        "arrays",
        "push",
        "methods"
      ],
      "relatedConcepts": [
        "Array methods",
        "Mutating methods",
        "Return values"
      ]
    },
    {
      "id": 2,
      "category": "arrays",
      "difficulty": "beginner",
      "type": "output",
      "title": "Array Pop Method",
      "question": "What will be the output of the following code?",
      "code": "const arr = [1, 2, 3];\nconst result = arr.pop();\nconsole.log(result);\nconsole.log(arr);",
      "options": [
        "3, [1, 2]",
        "[1, 2], 3",
        "3, [1, 2, 3]",
        "2, [1, 2]"
      ],
      "correctAnswer": 0,
      "explanation": "Array.pop() removes and returns the last element from an array. The original array is modified.",
      "hints": [
        "pop() removes the last element",
        "pop() returns the removed element"
      ],
      "tags": [
        "arrays",
        "pop",
        "methods"
      ],
      "relatedConcepts": [
        "Array methods",
        "Mutating methods",
        "Return values"
      ]
    },
    {
      "id": 3,
      "category": "arrays",
      "difficulty": "intermediate",
      "type": "output",
      "title": "Array Map Method",
      "question": "What will be the output of the following code?",
      "code": "const arr = [1, 2, 3];\nconst result = arr.map(x => x * 2);\nconsole.log(result);\nconsole.log(arr);",
      "options": [
        "[2, 4, 6], [1, 2, 3]",
        "[1, 2, 3], [2, 4, 6]",
        "[2, 4, 6], [2, 4, 6]",
        "[1, 2, 3], [1, 2, 3]"
      ],
      "correctAnswer": 0,
      "explanation": "Array.map() creates a new array with transformed elements. The original array remains unchanged.",
      "hints": [
        "map() creates a new array",
        "map() doesn't modify the original array"
      ],
      "tags": [
        "arrays",
        "map",
        "methods",
        "functional"
      ],
      "relatedConcepts": [
        "Array methods",
        "Non-mutating methods",
        "Functional programming"
      ]
    },
    {
      "id": 4,
      "category": "arrays",
      "difficulty": "intermediate",
      "type": "output",
      "title": "Array Filter Method",
      "question": "What will be the output of the following code?",
      "code": "const arr = [1, 2, 3, 4, 5];\nconst result = arr.filter(x => x % 2 === 0);\nconsole.log(result);",
      "options": [
        "[2, 4]",
        "[1, 3, 5]",
        "[1, 2, 3, 4, 5]",
        "[]"
      ],
      "correctAnswer": 0,
      "explanation": "Array.filter() creates a new array with elements that pass the test implemented by the provided function.",
      "hints": [
        "filter() creates a new array",
        "Only elements that return true are included"
      ],
      "tags": [
        "arrays",
        "filter",
        "methods",
        "functional"
      ],
      "relatedConcepts": [
        "Array methods",
        "Filtering",
        "Functional programming"
      ]
    },
    {
      "id": 5,
      "category": "arrays",
      "difficulty": "advanced",
      "type": "output",
      "title": "Array Reduce Method",
      "question": "What will be the output of the following code?",
      "code": "const arr = [1, 2, 3, 4];\nconst result = arr.reduce((acc, curr) => acc + curr, 0);\nconsole.log(result);",
      "options": [
        "10",
        "0",
        "[1, 2, 3, 4]",
        "4"
      ],
      "correctAnswer": 0,
      "explanation": "Array.reduce() executes a reducer function on each element, resulting in a single output value. Here it sums all elements.",
      "hints": [
        "reduce() combines all elements into one value",
        "Initial value is 0"
      ],
      "tags": [
        "arrays",
        "reduce",
        "methods",
        "functional"
      ],
      "relatedConcepts": [
        "Array methods",
        "Accumulation",
        "Functional programming"
      ]
    },
    {
      "id": 6,
      "category": "arrays",
      "difficulty": "intermediate",
      "type": "output",
      "title": "Array Method Chaining",
      "question": "What will be the output of the following code?",
      "code": "const arr = [1, 2, 3, 4, 5];\nconst result = arr\n  .filter(x => x > 2)\n  .map(x => x * 2)\n  .reduce((sum, x) => sum + x, 0);\nconsole.log(result);",
      "options": [
        "24",
        "30",
        "12",
        "15"
      ],
      "correctAnswer": 0,
      "explanation": "Method chaining: filter([3,4,5]) → map([6,8,10]) → reduce(6+8+10=24)",
      "hints": [
        "Chain executes left to right",
        "filter first, then map, then reduce"
      ],
      "tags": [
        "arrays",
        "chaining",
        "methods",
        "functional"
      ],
      "relatedConcepts": [
        "Method chaining",
        "Functional programming",
        "Data transformation"
      ]
    },
    {
      "id": 7,
      "category": "arrays",
      "difficulty": "beginner",
      "type": "output",
      "title": "Array Length Property",
      "question": "What will be the output of the following code?",
      "code": "const arr = [1, 2, 3];\narr[5] = 6;\nconsole.log(arr.length);\nconsole.log(arr);",
      "options": [
        "6, [1, 2, 3, undefined, undefined, 6]",
        "4, [1, 2, 3, 6]",
        "3, [1, 2, 3]",
        "5, [1, 2, 3, undefined, 6]"
      ],
      "correctAnswer": 0,
      "explanation": "Setting an element at index 5 creates empty slots (sparse array). Length becomes 6.",
      "hints": [
        "Arrays can have empty slots",
        "Length is based on highest index + 1"
      ],
      "tags": [
        "arrays",
        "length",
        "sparse"
      ],
      "relatedConcepts": [
        "Array length",
        "Sparse arrays",
        "Array indexing"
      ]
    },
    {
      "id": 8,
      "category": "arrays",
      "difficulty": "intermediate",
      "type": "output",
      "title": "Array Splice Method",
      "question": "What will be the output of the following code?",
      "code": "const arr = [1, 2, 3, 4, 5];\nconst result = arr.splice(2, 2, 'a', 'b');\nconsole.log(result);\nconsole.log(arr);",
      "options": [
        "[3, 4], [1, 2, 'a', 'b', 5]",
        "['a', 'b'], [1, 2, 3, 4, 5]",
        "[1, 2, 5], [3, 4, 'a', 'b']",
        "[3, 4], [1, 2, 3, 4, 'a', 'b', 5]"
      ],
      "correctAnswer": 0,
      "explanation": "splice(start, deleteCount, ...items) removes elements and adds new ones. Returns removed elements.",
      "hints": [
        "splice() modifies the original array",
        "Returns array of removed elements"
      ],
      "tags": [
        "arrays",
        "splice",
        "methods",
        "mutating"
      ],
      "relatedConcepts": [
        "Array methods",
        "Mutating methods",
        "Array modification"
      ]
    },
    {
      "id": 9,
      "category": "arrays",
      "difficulty": "intermediate",
      "type": "output",
      "title": "Array Slice Method",
      "question": "What will be the output of the following code?",
      "code": "const arr = [1, 2, 3, 4, 5];\nconst result = arr.slice(1, 4);\nconsole.log(result);\nconsole.log(arr);",
      "options": [
        "[2, 3, 4], [1, 2, 3, 4, 5]",
        "[1, 2, 3], [4, 5]",
        "[2, 3, 4], [1, 5]",
        "[1, 2, 3, 4], [5]"
      ],
      "correctAnswer": 0,
      "explanation": "slice(start, end) returns a shallow copy of a portion. Original array is unchanged. End index is exclusive.",
      "hints": [
        "slice() doesn't modify original array",
        "End index is not included"
      ],
      "tags": [
        "arrays",
        "slice",
        "methods",
        "non-mutating"
      ],
      "relatedConcepts": [
        "Array methods",
        "Non-mutating methods",
        "Array copying"
      ]
    },
    {
      "id": 10,
      "category": "arrays",
      "difficulty": "advanced",
      "type": "output",
      "title": "Array Find and FindIndex",
      "question": "What will be the output of the following code?",
      "code": "const arr = [{id: 1, name: 'Alice'}, {id: 2, name: 'Bob'}];\nconst found = arr.find(item => item.id === 2);\nconst index = arr.findIndex(item => item.id === 2);\nconsole.log(found?.name);\nconsole.log(index);",
      "options": [
        "Bob, 1",
        "undefined, -1",
        "Bob, 2",
        "{id: 2, name: 'Bob'}, 1"
      ],
      "correctAnswer": 0,
      "explanation": "find() returns the first element that matches. findIndex() returns its index. Bob is at index 1.",
      "hints": [
        "find() returns the element itself",
        "findIndex() returns the index position"
      ],
      "tags": [
        "arrays",
        "find",
        "findIndex",
        "objects"
      ],
      "relatedConcepts": [
        "Array search methods",
        "Object arrays",
        "Optional chaining"
      ]
    },
    {
      "id": 11,
      "category": "variables",
      "difficulty": "beginner",
      "type": "output",
      "title": "Variable Hoisting with Var",
      "question": "What will be the output of the following code?",
      "code": "console.log(x);\nvar x = 5;\nconsole.log(x);",
      "options": [
        "undefined, 5",
        "5, 5",
        "ReferenceError",
        "undefined, undefined"
      ],
      "correctAnswer": 0,
      "explanation": "Due to hoisting, 'var x' is moved to the top but not its assignment. So x is undefined initially, then 5 after assignment.",
      "hints": [
        "Think about how var declarations are hoisted",
        "Assignment happens where you write it"
      ],
      "tags": [
        "hoisting",
        "var",
        "undefined"
      ],
      "relatedConcepts": [
        "Variable declarations",
        "Hoisting",
        "Temporal dead zone"
      ]
    },
    {
      "id": 12,
      "category": "variables",
      "difficulty": "intermediate",
      "type": "output",
      "title": "Let vs Var in Loops",
      "question": "What will be the output of the following code?",
      "code": "for (var i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 0);\n}\n\nfor (let j = 0; j < 3; j++) {\n  setTimeout(() => console.log(j), 0);\n}",
      "options": [
        "3, 3, 3, 0, 1, 2",
        "0, 1, 2, 0, 1, 2",
        "0, 1, 2, 3, 3, 3",
        "3, 3, 3, 3, 3, 3"
      ],
      "correctAnswer": 0,
      "explanation": "With 'var', there's one variable shared across iterations. With 'let', each iteration gets its own variable due to block scoping.",
      "hints": [
        "Consider the difference between var and let scoping",
        "Think about when setTimeout callbacks execute"
      ],
      "tags": [
        "var",
        "let",
        "setTimeout",
        "scoping"
      ],
      "relatedConcepts": [
        "Block scoping",
        "Function scoping",
        "Event loop"
      ]
    },
    {
      "id": 13,
      "category": "variables",
      "difficulty": "beginner",
      "type": "output",
      "title": "Temporal Dead Zone",
      "question": "What will be the output of the following code?",
      "code": "console.log(x);\nlet x = 5;",
      "options": [
        "undefined",
        "5",
        "ReferenceError",
        "null"
      ],
      "correctAnswer": 2,
      "explanation": "Variables declared with let/const are hoisted but cannot be accessed before declaration due to temporal dead zone.",
      "hints": [
        "let/const have different hoisting behavior than var",
        "Temporal dead zone prevents access before declaration"
      ],
      "tags": [
        "temporal-dead-zone",
        "let",
        "hoisting"
      ],
      "relatedConcepts": [
        "Temporal dead zone",
        "Block scoping",
        "Hoisting"
      ]
    },
    {
      "id": 14,
      "category": "variables",
      "difficulty": "intermediate",
      "type": "output",
      "title": "Const Object Mutation",
      "question": "What will be the output of the following code?",
      "code": "const obj = {a: 1, b: 2};\nobj.a = 10;\nobj.c = 3;\nconsole.log(obj);",
      "options": [
        "{a: 10, b: 2, c: 3}",
        "{a: 1, b: 2}",
        "TypeError",
        "{a: 1, b: 2, c: 3}"
      ],
      "correctAnswer": 0,
      "explanation": "const prevents reassignment of the variable, but object properties can still be modified.",
      "hints": [
        "const prevents variable reassignment",
        "Object properties can still be changed"
      ],
      "tags": [
        "const",
        "objects",
        "mutation"
      ],
      "relatedConcepts": [
        "const keyword",
        "Object mutability",
        "Reference vs value"
      ]
    },
    {
      "id": 15,
      "category": "variables",
      "difficulty": "intermediate",
      "type": "output",
      "title": "Block Scope with Let",
      "question": "What will be the output of the following code?",
      "code": "let x = 1;\nif (true) {\n  let x = 2;\n  console.log(x);\n}\nconsole.log(x);",
      "options": [
        "2, 1",
        "1, 1",
        "2, 2",
        "1, 2"
      ],
      "correctAnswer": 0,
      "explanation": "let has block scope. The inner x is a different variable that shadows the outer x within the block.",
      "hints": [
        "let has block scope",
        "Inner variable shadows outer variable"
      ],
      "tags": [
        "let",
        "block-scope",
        "shadowing"
      ],
      "relatedConcepts": [
        "Block scoping",
        "Variable shadowing",
        "Lexical scoping"
      ]
    },
    {
      "id": 16,
      "category": "functions",
      "difficulty": "beginner",
      "type": "output",
      "title": "Function Declaration vs Expression",
      "question": "What will be the output of the following code?",
      "code": "console.log(foo());\nconsole.log(bar());\n\nfunction foo() { return 'foo'; }\nvar bar = function() { return 'bar'; };",
      "options": [
        "foo, TypeError",
        "undefined, bar",
        "ReferenceError, ReferenceError",
        "foo, bar"
      ],
      "correctAnswer": 0,
      "explanation": "Function declarations are hoisted completely. Function expressions are not hoisted (bar is undefined when called).",
      "hints": [
        "Function declarations are fully hoisted",
        "Function expressions follow var hoisting rules"
      ],
      "tags": [
        "functions",
        "hoisting",
        "declarations"
      ],
      "relatedConcepts": [
        "Function hoisting",
        "Function declarations",
        "Function expressions"
      ]
    },
    {
      "id": 17,
      "category": "functions",
      "difficulty": "intermediate",
      "type": "output",
      "title": "Arrow Function This Binding",
      "question": "What will be the output of the following code?",
      "code": "const obj = {\n  name: 'Alice',\n  greet: () => {\n    console.log('Hello ' + this.name);\n  }\n};\nobj.greet();",
      "options": [
        "Hello Alice",
        "Hello undefined",
        "Hello ",
        "TypeError"
      ],
      "correctAnswer": 2,
      "explanation": "Arrow functions don't have their own 'this'. They inherit 'this' from the lexical scope (global in this case).",
      "hints": [
        "Arrow functions don't bind their own 'this'",
        "this.name is undefined in global scope"
      ],
      "tags": [
        "arrow-functions",
        "this",
        "binding"
      ],
      "relatedConcepts": [
        "Arrow functions",
        "This binding",
        "Lexical scoping"
      ]
    },
    {
      "id": 18,
      "category": "functions",
      "difficulty": "intermediate",
      "type": "output",
      "title": "Regular Function This Binding",
      "question": "What will be the output of the following code?",
      "code": "const obj = {\n  name: 'Alice',\n  greet: function() {\n    console.log('Hello ' + this.name);\n  }\n};\nobj.greet();",
      "options": [
        "Hello Alice",
        "Hello undefined",
        "Hello ",
        "TypeError"
      ],
      "correctAnswer": 0,
      "explanation": "Regular functions bind 'this' to the object that calls them. Here, 'this' refers to obj.",
      "hints": [
        "Regular functions bind 'this' to the calling object",
        "obj.greet() means 'this' is obj"
      ],
      "tags": [
        "functions",
        "this",
        "binding"
      ],
      "relatedConcepts": [
        "Function this binding",
        "Method calls",
        "Object methods"
      ]
    },
    {
      "id": 19,
      "category": "functions",
      "difficulty": "advanced",
      "type": "output",
      "title": "Higher Order Functions",
      "question": "What will be the output of the following code?",
      "code": "function multiplier(factor) {\n  return function(number) {\n    return number * factor;\n  };\n}\n\nconst double = multiplier(2);\nconst triple = multiplier(3);\nconsole.log(double(5));\nconsole.log(triple(4));",
      "options": [
        "10, 12",
        "7, 7",
        "5, 4",
        "2, 3"
      ],
      "correctAnswer": 0,
      "explanation": "multiplier returns a function that remembers the factor. double multiplies by 2, triple by 3.",
      "hints": [
        "multiplier returns a function",
        "Each returned function remembers its factor"
      ],
      "tags": [
        "higher-order",
        "closures",
        "functions"
      ],
      "relatedConcepts": [
        "Higher-order functions",
        "Closures",
        "Function factories"
      ]
    },
    {
      "id": 20,
      "category": "functions",
      "difficulty": "intermediate",
      "type": "output",
      "title": "Function Parameters and Arguments",
      "question": "What will be the output of the following code?",
      "code": "function test(a, b = 2, c) {\n  console.log(a, b, c);\n}\n\ntest(1);\ntest(1, undefined, 3);",
      "options": [
        "1 2 undefined, 1 2 3",
        "1 undefined undefined, 1 undefined 3",
        "1 2 undefined, 1 undefined 3",
        "undefined 2 undefined, 1 2 3"
      ],
      "correctAnswer": 0,
      "explanation": "Default parameters apply when argument is undefined or missing. b defaults to 2 in both cases.",
      "hints": [
        "Default parameters work when argument is undefined",
        "Missing arguments are undefined"
      ],
      "tags": [
        "functions",
        "parameters",
        "defaults"
      ],
      "relatedConcepts": [
        "Default parameters",
        "Function arguments",
        "undefined values"
      ]
    },
    {
      "id": 21,
      "category": "objects",
      "difficulty": "beginner",
      "type": "output",
      "title": "Object Property Access",
      "question": "What will be the output of the following code?",
      "code": "const obj = { name: 'Alice', age: 30 };\nconsole.log(obj.name);\nconsole.log(obj['age']);\nconsole.log(obj.height);",
      "options": [
        "Alice, 30, undefined",
        "Alice, age, undefined",
        "name, 30, null",
        "Alice, 30, null"
      ],
      "correctAnswer": 0,
      "explanation": "Properties can be accessed with dot notation or bracket notation. Non-existent properties return undefined.",
      "hints": [
        "Both dot and bracket notation work",
        "Missing properties return undefined"
      ],
      "tags": [
        "objects",
        "properties",
        "access"
      ],
      "relatedConcepts": [
        "Object property access",
        "Dot notation",
        "Bracket notation"
      ]
    },
    {
      "id": 22,
      "category": "objects",
      "difficulty": "intermediate",
      "type": "output",
      "title": "Object Property Shorthand",
      "question": "What will be the output of the following code?",
      "code": "const name = 'Alice';\nconst age = 30;\nconst obj = { name, age, greet() { return 'Hello'; } };\nconsole.log(obj.name);\nconsole.log(obj.greet());",
      "options": [
        "Alice, Hello",
        "name, greet()",
        "undefined, undefined",
        "Alice, function"
      ],
      "correctAnswer": 0,
      "explanation": "ES6 property shorthand allows { name } instead of { name: name }. Method shorthand works too.",
      "hints": [
        "Property shorthand uses variable name as key",
        "Method shorthand is valid ES6 syntax"
      ],
      "tags": [
        "objects",
        "es6",
        "shorthand"
      ],
      "relatedConcepts": [
        "Object shorthand",
        "ES6 features",
        "Method definitions"
      ]
    },
    {
      "id": 23,
      "category": "objects",
      "difficulty": "intermediate",
      "type": "output",
      "title": "Object Destructuring",
      "question": "What will be the output of the following code?",
      "code": "const obj = { x: 1, y: 2, z: 3 };\nconst { x, y: newY, w = 10 } = obj;\nconsole.log(x);\nconsole.log(newY);\nconsole.log(w);",
      "options": [
        "1, 2, 10",
        "x, y, w",
        "1, undefined, 10",
        "undefined, 2, undefined"
      ],
      "correctAnswer": 0,
      "explanation": "Destructuring extracts x (1), renames y to newY (2), and w gets default value (10) since it doesn't exist.",
      "hints": [
        "Destructuring can rename variables",
        "Default values work for missing properties"
      ],
      "tags": [
        "objects",
        "destructuring",
        "es6"
      ],
      "relatedConcepts": [
        "Object destructuring",
        "Variable renaming",
        "Default values"
      ]
    },
    {
      "id": 24,
      "category": "objects",
      "difficulty": "advanced",
      "type": "output",
      "title": "Object.keys and Object.values",
      "question": "What will be the output of the following code?",
      "code": "const obj = { a: 1, b: 2, c: 3 };\nconst keys = Object.keys(obj);\nconst values = Object.values(obj);\nconsole.log(keys.length);\nconsole.log(values.reduce((sum, v) => sum + v, 0));",
      "options": [
        "3, 6",
        "3, 3",
        "1, 6",
        "undefined, undefined"
      ],
      "correctAnswer": 0,
      "explanation": "Object.keys() returns array of property names (length 3). Object.values() returns [1,2,3], sum is 6.",
      "hints": [
        "Object.keys() returns array of property names",
        "Object.values() returns array of property values"
      ],
      "tags": [
        "objects",
        "keys",
        "values"
      ],
      "relatedConcepts": [
        "Object.keys",
        "Object.values",
        "Object iteration"
      ]
    },
    {
      "id": 25,
      "category": "objects",
      "difficulty": "intermediate",
      "type": "output",
      "title": "Object Reference vs Copy",
      "question": "What will be the output of the following code?",
      "code": "const obj1 = { a: 1 };\nconst obj2 = obj1;\nconst obj3 = { ...obj1 };\nobj1.a = 2;\nconsole.log(obj2.a);\nconsole.log(obj3.a);",
      "options": [
        "2, 1",
        "1, 1",
        "2, 2",
        "1, 2"
      ],
      "correctAnswer": 0,
      "explanation": "obj2 references the same object as obj1. obj3 is a shallow copy, so it's not affected by changes to obj1.",
      "hints": [
        "Assignment creates a reference",
        "Spread operator creates a shallow copy"
      ],
      "tags": [
        "objects",
        "reference",
        "copying"
      ],
      "relatedConcepts": [
        "Object references",
        "Object copying",
        "Spread operator"
      ]
    },
    {
      "id": 26,
      "category": "closures",
      "difficulty": "intermediate",
      "type": "output",
      "title": "Basic Closure",
      "question": "What will be the output of the following code?",
      "code": "function outer() {\n  let count = 0;\n  return function() {\n    count++;\n    return count;\n  };\n}\n\nconst counter = outer();\nconsole.log(counter());\nconsole.log(counter());",
      "options": [
        "1, 2",
        "0, 1",
        "1, 1",
        "undefined, undefined"
      ],
      "correctAnswer": 0,
      "explanation": "The inner function has access to the outer function's count variable even after outer() has finished executing.",
      "hints": [
        "Inner function can access outer variables",
        "count persists between calls"
      ],
      "tags": [
        "closures",
        "scope",
        "functions"
      ],
      "relatedConcepts": [
        "Closures",
        "Lexical scoping",
        "Function scope"
      ]
    },
    {
      "id": 27,
      "category": "closures",
      "difficulty": "advanced",
      "type": "output",
      "title": "Closure in Loop",
      "question": "What will be the output of the following code?",
      "code": "const functions = [];\nfor (let i = 0; i < 3; i++) {\n  functions.push(() => i);\n}\nconsole.log(functions[0]());\nconsole.log(functions[1]());\nconsole.log(functions[2]());",
      "options": [
        "0, 1, 2",
        "3, 3, 3",
        "undefined, undefined, undefined",
        "0, 0, 0"
      ],
      "correctAnswer": 0,
      "explanation": "With let, each iteration creates a new binding for i, so each function captures its own value.",
      "hints": [
        "let creates a new binding each iteration",
        "Each function captures its own i value"
      ],
      "tags": [
        "closures",
        "loops",
        "let"
      ],
      "relatedConcepts": [
        "Closures",
        "Block scoping",
        "Loop variables"
      ]
    },
    {
      "id": 28,
      "category": "closures",
      "difficulty": "advanced",
      "type": "output",
      "title": "Module Pattern with Closure",
      "question": "What will be the output of the following code?",
      "code": "const module = (function() {\n  let private = 0;\n  return {\n    increment() { private++; },\n    get() { return private; }\n  };\n})();\n\nmodule.increment();\nmodule.increment();\nconsole.log(module.get());\nconsole.log(module.private);",
      "options": [
        "2, undefined",
        "0, 0",
        "2, 2",
        "undefined, undefined"
      ],
      "correctAnswer": 0,
      "explanation": "IIFE creates a closure with private variable. Only exposed methods can access it, direct access returns undefined.",
      "hints": [
        "IIFE creates immediate closure",
        "private variable is not directly accessible"
      ],
      "tags": [
        "closures",
        "modules",
        "iife"
      ],
      "relatedConcepts": [
        "Module pattern",
        "IIFE",
        "Data privacy"
      ]
    },
    {
      "id": 29,
      "category": "loops",
      "difficulty": "beginner",
      "type": "output",
      "title": "For Loop Basic",
      "question": "What will be the output of the following code?",
      "code": "for (let i = 0; i < 3; i++) {\n  console.log(i);\n}",
      "options": [
        "0, 1, 2",
        "1, 2, 3",
        "0, 1, 2, 3",
        "1, 2"
      ],
      "correctAnswer": 0,
      "explanation": "Loop starts at 0, continues while i < 3, incrementing i each time. Outputs 0, 1, 2.",
      "hints": [
        "Loop condition is i < 3",
        "i starts at 0 and increments"
      ],
      "tags": [
        "loops",
        "for",
        "iteration"
      ],
      "relatedConcepts": [
        "For loops",
        "Loop conditions",
        "Iteration"
      ]
    },
    {
      "id": 30,
      "category": "loops",
      "difficulty": "intermediate",
      "type": "output",
      "title": "ForEach vs Map",
      "question": "What will be the output of the following code?",
      "code": "const arr = [1, 2, 3];\nconst result1 = arr.forEach(x => x * 2);\nconst result2 = arr.map(x => x * 2);\nconsole.log(result1);\nconsole.log(result2);",
      "options": [
        "undefined, [2, 4, 6]",
        "[2, 4, 6], [2, 4, 6]",
        "[1, 2, 3], [2, 4, 6]",
        "undefined, undefined"
      ],
      "correctAnswer": 0,
      "explanation": "forEach() returns undefined and is used for side effects. map() returns a new array with transformed values.",
      "hints": [
        "forEach returns undefined",
        "map returns a new array"
      ],
      "tags": [
        "loops",
        "forEach",
        "map"
      ],
      "relatedConcepts": [
        "Array iteration",
        "forEach vs map",
        "Return values"
      ]
    },
    {
      "id": 31,
      "category": "strings",
      "difficulty": "beginner",
      "type": "output",
      "title": "String Template Literals",
      "question": "What will be the output of the following code?",
      "code": "const name = 'Alice';\nconst age = 30;\nconst message = `Hello, my name is ${name} and I am ${age} years old.`;\nconsole.log(message);",
      "options": [
        "Hello, my name is Alice and I am 30 years old.",
        "Hello, my name is ${name} and I am ${age} years old.",
        "Hello, my name is name and I am age years old.",
        "SyntaxError"
      ],
      "correctAnswer": 0,
      "explanation": "Template literals use backticks and ${} for variable interpolation.",
      "hints": [
        "Template literals use backticks",
        "${} interpolates variables"
      ],
      "tags": [
        "strings",
        "template-literals",
        "interpolation"
      ],
      "relatedConcepts": [
        "Template literals",
        "String interpolation",
        "ES6 features"
      ]
    },
    {
      "id": 32,
      "category": "strings",
      "difficulty": "intermediate",
      "type": "output",
      "title": "String Methods",
      "question": "What will be the output of the following code?",
      "code": "const str = 'Hello World';\nconsole.log(str.toLowerCase());\nconsole.log(str.slice(0, 5));\nconsole.log(str.includes('World'));",
      "options": [
        "hello world, Hello, true",
        "HELLO WORLD, Hello, false",
        "hello world, Hell, true",
        "Hello World, Hello, true"
      ],
      "correctAnswer": 0,
      "explanation": "toLowerCase() converts to lowercase, slice(0,5) extracts 'Hello', includes() checks if substring exists.",
      "hints": [
        "toLowerCase affects all characters",
        "slice(0,5) extracts first 5 characters"
      ],
      "tags": [
        "strings",
        "methods",
        "manipulation"
      ],
      "relatedConcepts": [
        "String methods",
        "String manipulation",
        "String searching"
      ]
    },
    {
      "id": 33,
      "category": "operators",
      "difficulty": "intermediate",
      "type": "output",
      "title": "Comparison Operators",
      "question": "What will be the output of the following code?",
      "code": "console.log(5 == '5');\nconsole.log(5 === '5');\nconsole.log(0 == false);\nconsole.log(0 === false);",
      "options": [
        "true, false, true, false",
        "false, false, false, false",
        "true, true, true, true",
        "false, true, false, true"
      ],
      "correctAnswer": 0,
      "explanation": "== performs type coercion, === doesn't. 5 == '5' (coerced), 5 !== '5' (different types), 0 == false (coerced), 0 !== false (different types).",
      "hints": [
        "== allows type coercion",
        "=== requires same type and value"
      ],
      "tags": [
        "operators",
        "comparison",
        "coercion"
      ],
      "relatedConcepts": [
        "Comparison operators",
        "Type coercion",
        "Equality"
      ]
    },
    {
      "id": 34,
      "category": "operators",
      "difficulty": "intermediate",
      "type": "output",
      "title": "Logical Operators Short Circuit",
      "question": "What will be the output of the following code?",
      "code": "const result1 = false && console.log('A');\nconst result2 = true || console.log('B');\nconst result3 = null ?? 'default';\nconsole.log(result3);",
      "options": [
        "default",
        "A, B, default",
        "undefined, undefined, default",
        "false, true, default"
      ],
      "correctAnswer": 0,
      "explanation": "&& short-circuits on false (doesn't execute console.log). || short-circuits on true. ?? returns 'default' for null.",
      "hints": [
        "&& stops on first falsy value",
        "|| stops on first truthy value",
        "?? handles null/undefined"
      ],
      "tags": [
        "operators",
        "logical",
        "short-circuit"
      ],
      "relatedConcepts": [
        "Logical operators",
        "Short-circuit evaluation",
        "Nullish coalescing"
      ]
    },
    {
      "id": 35,
      "category": "es6",
      "difficulty": "intermediate",
      "type": "output",
      "title": "Spread Operator with Arrays",
      "question": "What will be the output of the following code?",
      "code": "const arr1 = [1, 2];\nconst arr2 = [3, 4];\nconst combined = [...arr1, ...arr2, 5];\nconsole.log(combined);",
      "options": [
        "[1, 2, 3, 4, 5]",
        "[[1, 2], [3, 4], 5]",
        "[1, 2, [3, 4], 5]",
        "SyntaxError"
      ],
      "correctAnswer": 0,
      "explanation": "Spread operator (...) expands arrays into individual elements. Creates a new array with all elements.",
      "hints": [
        "Spread operator expands array elements",
        "Creates a new flat array"
      ],
      "tags": [
        "es6",
        "spread",
        "arrays"
      ],
      "relatedConcepts": [
        "Spread operator",
        "Array spreading",
        "ES6 features"
      ]
    },
    {
      "id": 36,
      "category": "es6",
      "difficulty": "intermediate",
      "type": "output",
      "title": "Rest Parameters",
      "question": "What will be the output of the following code?",
      "code": "function sum(first, ...rest) {\n  console.log(first);\n  console.log(rest);\n}\n\nsum(1, 2, 3, 4, 5);",
      "options": [
        "1, [2, 3, 4, 5]",
        "[1], [2, 3, 4, 5]",
        "1, 2, 3, 4, 5",
        "undefined, [1, 2, 3, 4, 5]"
      ],
      "correctAnswer": 0,
      "explanation": "Rest parameters (...rest) collect remaining arguments into an array. first gets 1, rest gets [2,3,4,5].",
      "hints": [
        "Rest parameters collect remaining arguments",
        "First parameter gets first argument"
      ],
      "tags": [
        "es6",
        "rest",
        "parameters"
      ],
      "relatedConcepts": [
        "Rest parameters",
        "Function parameters",
        "ES6 features"
      ]
    },
    {
      "id": 37,
      "category": "promises",
      "difficulty": "intermediate",
      "type": "output",
      "title": "Promise Basic Usage",
      "question": "What will be the output of the following code?",
      "code": "const promise = Promise.resolve('Success');\npromise.then(result => console.log(result));\nconsole.log('Immediate');",
      "options": [
        "Immediate, Success",
        "Success, Immediate",
        "Immediate",
        "Success"
      ],
      "correctAnswer": 0,
      "explanation": "Synchronous code runs first ('Immediate'), then promise callback runs asynchronously ('Success').",
      "hints": [
        "Synchronous code runs before async callbacks",
        "Promise.then is asynchronous"
      ],
      "tags": [
        "promises",
        "async",
        "order"
      ],
      "relatedConcepts": [
        "Promises",
        "Event loop",
        "Asynchronous execution"
      ]
    },
    {
      "id": 38,
      "category": "error-handling",
      "difficulty": "intermediate",
      "type": "output",
      "title": "Try Catch Finally",
      "question": "What will be the output of the following code?",
      "code": "try {\n  console.log('Try');\n  throw new Error('Oops');\n  console.log('After throw');\n} catch (e) {\n  console.log('Catch');\n} finally {\n  console.log('Finally');\n}",
      "options": [
        "Try, Catch, Finally",
        "Try, After throw, Catch, Finally",
        "Try, Finally",
        "Catch, Finally"
      ],
      "correctAnswer": 0,
      "explanation": "Try executes until throw, then catch handles the error, finally always executes. Code after throw is skipped.",
      "hints": [
        "throw stops execution in try block",
        "finally always runs"
      ],
      "tags": [
        "error-handling",
        "try-catch",
        "finally"
      ],
      "relatedConcepts": [
        "Error handling",
        "Try-catch-finally",
        "Exception handling"
      ]
    },
    {
      "id": 39,
      "category": "advanced",
      "difficulty": "advanced",
      "type": "output",
      "title": "Event Loop and Microtasks",
      "question": "What will be the output of the following code?",
      "code": "console.log('1');\nsetTimeout(() => console.log('2'), 0);\nPromise.resolve().then(() => console.log('3'));\nconsole.log('4');",
      "options": [
        "1, 4, 3, 2",
        "1, 2, 3, 4",
        "1, 3, 4, 2",
        "1, 4, 2, 3"
      ],
      "correctAnswer": 0,
      "explanation": "Synchronous code runs first (1, 4), then microtasks (Promise - 3), then macrotasks (setTimeout - 2).",
      "hints": [
        "Synchronous code runs first",
        "Microtasks have higher priority than macrotasks"
      ],
      "tags": [
        "advanced",
        "event-loop",
        "microtasks"
      ],
      "relatedConcepts": [
        "Event loop",
        "Microtasks",
        "Macrotasks"
      ]
    },
    {
      "id": 40,
      "category": "advanced",
      "difficulty": "advanced",
      "type": "output",
      "title": "Proxy Object",
      "question": "What will be the output of the following code?",
      "code": "const obj = { name: 'Alice' };\nconst proxy = new Proxy(obj, {\n  get(target, prop) {\n    return prop in target ? target[prop] : 'Not found';\n  }\n});\nconsole.log(proxy.name);\nconsole.log(proxy.age);",
      "options": [
        "Alice, Not found",
        "Alice, undefined",
        "Not found, Not found",
        "Alice, Alice"
      ],
      "correctAnswer": 0,
      "explanation": "Proxy intercepts property access. name exists so returns 'Alice', age doesn't exist so returns 'Not found'.",
      "hints": [
        "Proxy intercepts property access",
        "get handler defines custom behavior"
      ],
      "tags": [
        "advanced",
        "proxy",
        "metaprogramming"
      ],
      "relatedConcepts": [
        "Proxy objects",
        "Metaprogramming",
        "Property access"
      ]
    },
    {
      "id": 41,
      "category": "arrays",
      "difficulty": "intermediate",
      "type": "output",
      "title": "Array Sort Method",
      "question": "What will be the output of the following code?",
      "code": "const numbers = [10, 5, 100, 2, 1000];\nnumbers.sort();\nconsole.log(numbers);",
      "options": [
        "[10, 100, 1000, 2, 5]",
        "[2, 5, 10, 100, 1000]",
        "[1000, 100, 10, 5, 2]",
        "[10, 5, 100, 2, 1000]"
      ],
      "correctAnswer": 0,
      "explanation": "Array.sort() converts elements to strings and sorts lexicographically by default. '10' comes before '2' as strings.",
      "hints": [
        "sort() converts to strings by default",
        "Lexicographic order: '10' < '2'"
      ],
      "tags": [
        "arrays",
        "sort",
        "strings"
      ],
      "relatedConcepts": [
        "Array sorting",
        "String comparison",
        "Lexicographic order"
      ]
    },
    {
      "id": 42,
      "category": "arrays",
      "difficulty": "advanced",
      "type": "output",
      "title": "Array Sort with Compare Function",
      "question": "What will be the output of the following code?",
      "code": "const numbers = [10, 5, 100, 2, 1000];\nnumbers.sort((a, b) => a - b);\nconsole.log(numbers);",
      "options": [
        "[2, 5, 10, 100, 1000]",
        "[10, 100, 1000, 2, 5]",
        "[1000, 100, 10, 5, 2]",
        "[10, 5, 100, 2, 1000]"
      ],
      "correctAnswer": 0,
      "explanation": "Compare function (a, b) => a - b sorts numbers in ascending order. Negative result means a < b.",
      "hints": [
        "Compare function controls sort order",
        "a - b gives ascending numeric sort"
      ],
      "tags": [
        "arrays",
        "sort",
        "comparison"
      ],
      "relatedConcepts": [
        "Array sorting",
        "Compare functions",
        "Numeric sorting"
      ]
    },
    {
      "id": 43,
      "category": "arrays",
      "difficulty": "intermediate",
      "type": "output",
      "title": "Array Includes vs IndexOf",
      "question": "What will be the output of the following code?",
      "code": "const arr = [1, 2, 3, NaN];\nconsole.log(arr.includes(NaN));\nconsole.log(arr.indexOf(NaN));",
      "options": [
        "true, -1",
        "false, -1",
        "true, 3",
        "false, 3"
      ],
      "correctAnswer": 0,
      "explanation": "includes() can find NaN correctly, but indexOf() cannot find NaN and returns -1.",
      "hints": [
        "includes() handles NaN correctly",
        "indexOf() cannot find NaN"
      ],
      "tags": [
        "arrays",
        "includes",
        "indexOf",
        "NaN"
      ],
      "relatedConcepts": [
        "Array search methods",
        "NaN comparison",
        "SameValueZero"
      ]
    },
    {
      "id": 44,
      "category": "arrays",
      "difficulty": "advanced",
      "type": "output",
      "title": "Array Flat Method",
      "question": "What will be the output of the following code?",
      "code": "const arr = [1, [2, [3, [4, 5]]], 6];\nconst result1 = arr.flat();\nconst result2 = arr.flat(2);\nconsole.log(result1.length);\nconsole.log(result2.length);",
      "options": [
        "4, 5",
        "3, 6",
        "6, 6",
        "4, 6"
      ],
      "correctAnswer": 0,
      "explanation": "flat() flattens one level: [1, 2, [3, [4, 5]], 6] (4 elements). flat(2) flattens two levels: [1, 2, 3, [4, 5], 6] (5 elements).",
      "hints": [
        "flat() flattens one level by default",
        "flat(2) flattens two levels"
      ],
      "tags": [
        "arrays",
        "flat",
        "nested"
      ],
      "relatedConcepts": [
        "Array flattening",
        "Nested arrays",
        "ES2019 features"
      ]
    },
    {
      "id": 45,
      "category": "variables",
      "difficulty": "advanced",
      "type": "output",
      "title": "Variable Hoisting Edge Case",
      "question": "What will be the output of the following code?",
      "code": "var x = 1;\nfunction test() {\n  console.log(x);\n  var x = 2;\n  console.log(x);\n}\ntest();",
      "options": [
        "undefined, 2",
        "1, 2",
        "undefined, undefined",
        "1, 1"
      ],
      "correctAnswer": 0,
      "explanation": "Local var x is hoisted to function top, shadowing global x. First console.log sees undefined hoisted variable.",
      "hints": [
        "Local var declaration shadows global variable",
        "Hoisting creates undefined local variable"
      ],
      "tags": [
        "variables",
        "hoisting",
        "shadowing"
      ],
      "relatedConcepts": [
        "Variable hoisting",
        "Function scope",
        "Variable shadowing"
      ]
    },
    {
      "id": 46,
      "category": "variables",
      "difficulty": "intermediate",
      "type": "output",
      "title": "Const Array Mutation",
      "question": "What will be the output of the following code?",
      "code": "const arr = [1, 2, 3];\narr.push(4);\narr[0] = 10;\nconsole.log(arr);",
      "options": [
        "[10, 2, 3, 4]",
        "[1, 2, 3]",
        "TypeError",
        "[1, 2, 3, 4]"
      ],
      "correctAnswer": 0,
      "explanation": "const prevents reassignment of the variable, but array contents can be modified.",
      "hints": [
        "const prevents variable reassignment",
        "Array contents can still be changed"
      ],
      "tags": [
        "const",
        "arrays",
        "mutation"
      ],
      "relatedConcepts": [
        "const keyword",
        "Array mutability",
        "Reference vs value"
      ]
    },
    {
      "id": 47,
      "category": "functions",
      "difficulty": "advanced",
      "type": "output",
      "title": "Function Call Apply Bind",
      "question": "What will be the output of the following code?",
      "code": "const obj = { name: 'Alice' };\nfunction greet(greeting) {\n  return greeting + ' ' + this.name;\n}\n\nconst result1 = greet.call(obj, 'Hello');\nconst result2 = greet.apply(obj, ['Hi']);\nconsole.log(result1);\nconsole.log(result2);",
      "options": [
        "Hello Alice, Hi Alice",
        "Hello undefined, Hi undefined",
        "Hello, Hi",
        "Alice Hello, Alice Hi"
      ],
      "correctAnswer": 0,
      "explanation": "Both call() and apply() set 'this' to obj. call() takes individual arguments, apply() takes an array.",
      "hints": [
        "call() and apply() set the 'this' context",
        "call() uses individual args, apply() uses array"
      ],
      "tags": [
        "functions",
        "call",
        "apply",
        "this"
      ],
      "relatedConcepts": [
        "Function call",
        "Function apply",
        "This binding"
      ]
    },
    {
      "id": 48,
      "category": "functions",
      "difficulty": "intermediate",
      "type": "output",
      "title": "Function Bind Method",
      "question": "What will be the output of the following code?",
      "code": "const obj = { name: 'Alice' };\nfunction greet() {\n  return 'Hello ' + this.name;\n}\n\nconst boundGreet = greet.bind(obj);\nconsole.log(boundGreet());",
      "options": [
        "Hello Alice",
        "Hello undefined",
        "Hello",
        "TypeError"
      ],
      "correctAnswer": 0,
      "explanation": "bind() creates a new function with 'this' permanently set to obj. When called, 'this' refers to obj.",
      "hints": [
        "bind() creates a new function with fixed 'this'",
        "Bound function remembers its context"
      ],
      "tags": [
        "functions",
        "bind",
        "this"
      ],
      "relatedConcepts": [
        "Function bind",
        "This binding",
        "Bound functions"
      ]
    },
    {
      "id": 49,
      "category": "objects",
      "difficulty": "advanced",
      "type": "output",
      "title": "Object Freeze vs Seal",
      "question": "What will be the output of the following code?",
      "code": "const obj1 = { a: 1 };\nObject.freeze(obj1);\nobj1.a = 2;\n\nconst obj2 = { b: 1 };\nObject.seal(obj2);\nobj2.b = 2;\n\nconsole.log(obj1.a);\nconsole.log(obj2.b);",
      "options": [
        "1, 2",
        "2, 2",
        "1, 1",
        "2, 1"
      ],
      "correctAnswer": 0,
      "explanation": "freeze() prevents all modifications. seal() allows modification of existing properties but prevents adding/deleting.",
      "hints": [
        "freeze() prevents all changes",
        "seal() allows modifying existing properties"
      ],
      "tags": [
        "objects",
        "freeze",
        "seal"
      ],
      "relatedConcepts": [
        "Object freeze",
        "Object seal",
        "Object immutability"
      ]
    },
    {
      "id": 50,
      "category": "objects",
      "difficulty": "intermediate",
      "type": "output",
      "title": "Object Computed Properties",
      "question": "What will be the output of the following code?",
      "code": "const key = 'dynamic';\nconst obj = {\n  static: 'value1',\n  [key]: 'value2',\n  ['prop_' + 3]: 'value3'\n};\nconsole.log(obj.dynamic);\nconsole.log(obj.prop_3);",
      "options": [
        "value2, value3",
        "undefined, undefined",
        "dynamic, prop_3",
        "value1, value1"
      ],
      "correctAnswer": 0,
      "explanation": "Computed property names use [] to evaluate expressions as property keys. [key] becomes 'dynamic'.",
      "hints": [
        "[] allows computed property names",
        "Expressions are evaluated as property keys"
      ],
      "tags": [
        "objects",
        "computed",
        "properties"
      ],
      "relatedConcepts": [
        "Computed properties",
        "Dynamic property names",
        "ES6 features"
      ]
    },
    {
      "id": 51,
      "category": "strings",
      "difficulty": "intermediate",
      "type": "output",
      "title": "String Split and Join",
      "question": "What will be the output of the following code?",
      "code": "const str = 'apple,banana,cherry';\nconst arr = str.split(',');\nconst result = arr.join(' | ');\nconsole.log(result);",
      "options": [
        "apple | banana | cherry",
        "apple,banana,cherry",
        "['apple', 'banana', 'cherry']",
        "apple banana cherry"
      ],
      "correctAnswer": 0,
      "explanation": "split(',') creates array from string. join(' | ') combines array elements with ' | ' separator.",
      "hints": [
        "split() creates array from string",
        "join() combines array with separator"
      ],
      "tags": [
        "strings",
        "split",
        "join",
        "arrays"
      ],
      "relatedConcepts": [
        "String splitting",
        "Array joining",
        "String manipulation"
      ]
    },
    {
      "id": 52,
      "category": "strings",
      "difficulty": "beginner",
      "type": "output",
      "title": "String Length and Indexing",
      "question": "What will be the output of the following code?",
      "code": "const str = 'JavaScript';\nconsole.log(str.length);\nconsole.log(str[0]);\nconsole.log(str[str.length - 1]);",
      "options": [
        "10, J, t",
        "9, J, t",
        "10, 0, 9",
        "9, 0, 8"
      ],
      "correctAnswer": 0,
      "explanation": "String length is 10. Index 0 is 'J', last index (length-1) is 't'.",
      "hints": [
        "String length counts all characters",
        "Last index is length - 1"
      ],
      "tags": [
        "strings",
        "length",
        "indexing"
      ],
      "relatedConcepts": [
        "String length",
        "String indexing",
        "Zero-based indexing"
      ]
    },
    {
      "id": 53,
      "category": "loops",
      "difficulty": "intermediate",
      "type": "output",
      "title": "While Loop with Break",
      "question": "What will be the output of the following code?",
      "code": "let i = 0;\nwhile (true) {\n  if (i === 3) break;\n  console.log(i);\n  i++;\n}",
      "options": [
        "0, 1, 2",
        "0, 1, 2, 3",
        "1, 2, 3",
        "Infinite loop"
      ],
      "correctAnswer": 0,
      "explanation": "Loop runs until i equals 3, then break exits. Outputs 0, 1, 2 before breaking.",
      "hints": [
        "break exits the loop immediately",
        "i is checked before console.log"
      ],
      "tags": [
        "loops",
        "while",
        "break"
      ],
      "relatedConcepts": [
        "While loops",
        "Break statement",
        "Loop control"
      ]
    },
    {
      "id": 54,
      "category": "loops",
      "difficulty": "intermediate",
      "type": "output",
      "title": "For Loop with Continue",
      "question": "What will be the output of the following code?",
      "code": "for (let i = 0; i < 5; i++) {\n  if (i === 2) continue;\n  console.log(i);\n}",
      "options": [
        "0, 1, 3, 4",
        "0, 1, 2, 3, 4",
        "1, 3, 4",
        "0, 1, 3"
      ],
      "correctAnswer": 0,
      "explanation": "continue skips the rest of the iteration when i equals 2. Outputs all except 2.",
      "hints": [
        "continue skips current iteration",
        "Loop continues with next iteration"
      ],
      "tags": [
        "loops",
        "for",
        "continue"
      ],
      "relatedConcepts": [
        "For loops",
        "Continue statement",
        "Loop control"
      ]
    },
    {
      "id": 55,
      "category": "operators",
      "difficulty": "advanced",
      "type": "output",
      "title": "Ternary Operator Chaining",
      "question": "What will be the output of the following code?",
      "code": "const score = 85;\nconst grade = score >= 90 ? 'A' : score >= 80 ? 'B' : score >= 70 ? 'C' : 'F';\nconsole.log(grade);",
      "options": [
        "B",
        "A",
        "C",
        "F"
      ],
      "correctAnswer": 0,
      "explanation": "Ternary operators chain left to right. 85 >= 90 is false, so check 85 >= 80 which is true, returns 'B'.",
      "hints": [
        "Ternary operators evaluate left to right",
        "85 >= 80 is the first true condition"
      ],
      "tags": [
        "operators",
        "ternary",
        "conditional"
      ],
      "relatedConcepts": [
        "Ternary operator",
        "Conditional expressions",
        "Operator precedence"
      ]
    },
    {
      "id": 56,
      "category": "operators",
      "difficulty": "intermediate",
      "type": "output",
      "title": "Typeof Operator",
      "question": "What will be the output of the following code?",
      "code": "console.log(typeof null);\nconsole.log(typeof undefined);\nconsole.log(typeof []);\nconsole.log(typeof {});",
      "options": [
        "object, undefined, object, object",
        "null, undefined, array, object",
        "object, undefined, array, object",
        "null, undefined, object, object"
      ],
      "correctAnswer": 0,
      "explanation": "typeof null is 'object' (JavaScript quirk). Arrays are objects. undefined and objects return expected types.",
      "hints": [
        "typeof null returns 'object' (known quirk)",
        "Arrays are technically objects"
      ],
      "tags": [
        "operators",
        "typeof",
        "types"
      ],
      "relatedConcepts": [
        "Typeof operator",
        "JavaScript types",
        "Type checking"
      ]
    },
    {
      "id": 57,
      "category": "es6",
      "difficulty": "intermediate",
      "type": "output",
      "title": "Array Destructuring with Defaults",
      "question": "What will be the output of the following code?",
      "code": "const [a, b = 2, c = 3] = [1];\nconsole.log(a);\nconsole.log(b);\nconsole.log(c);",
      "options": [
        "1, 2, 3",
        "1, undefined, undefined",
        "1, 2, undefined",
        "undefined, 2, 3"
      ],
      "correctAnswer": 0,
      "explanation": "Destructuring assigns a=1, b and c get default values since array only has one element.",
      "hints": [
        "Default values apply when element is missing",
        "Array has only one element"
      ],
      "tags": [
        "es6",
        "destructuring",
        "arrays",
        "defaults"
      ],
      "relatedConcepts": [
        "Array destructuring",
        "Default values",
        "ES6 features"
      ]
    },
    {
      "id": 58,
      "category": "es6",
      "difficulty": "advanced",
      "type": "output",
      "title": "Object Destructuring Nested",
      "question": "What will be the output of the following code?",
      "code": "const obj = { user: { name: 'Alice', age: 30 } };\nconst { user: { name, age } } = obj;\nconsole.log(name);\nconsole.log(age);",
      "options": [
        "Alice, 30",
        "undefined, undefined",
        "{name: 'Alice', age: 30}, undefined",
        "Alice, undefined"
      ],
      "correctAnswer": 0,
      "explanation": "Nested destructuring extracts name and age from the nested user object.",
      "hints": [
        "Nested destructuring accesses deep properties",
        "user: { name, age } extracts from user object"
      ],
      "tags": [
        "es6",
        "destructuring",
        "objects",
        "nested"
      ],
      "relatedConcepts": [
        "Nested destructuring",
        "Object destructuring",
        "ES6 features"
      ]
    },
    {
      "id": 59,
      "category": "promises",
      "difficulty": "intermediate",
      "type": "output",
      "title": "Promise Chain",
      "question": "What will be the output of the following code?",
      "code": "Promise.resolve(1)\n  .then(x => x + 1)\n  .then(x => x * 2)\n  .then(x => console.log(x));\nconsole.log('Immediate');",
      "options": [
        "Immediate, 4",
        "4, Immediate",
        "Immediate, 2",
        "2, Immediate"
      ],
      "correctAnswer": 0,
      "explanation": "Synchronous code runs first ('Immediate'), then promise chain: 1 + 1 = 2, 2 * 2 = 4.",
      "hints": [
        "Synchronous code runs before promise callbacks",
        "Promise chain: 1 → 2 → 4"
      ],
      "tags": [
        "promises",
        "chain",
        "then"
      ],
      "relatedConcepts": [
        "Promise chaining",
        "Asynchronous execution",
        "Promise methods"
      ]
    },
    {
      "id": 60,
      "category": "promises",
      "difficulty": "advanced",
      "type": "output",
      "title": "Promise All vs AllSettled",
      "question": "What will be the output of the following code?",
      "code": "const p1 = Promise.resolve(1);\nconst p2 = Promise.reject('error');\nconst p3 = Promise.resolve(3);\n\nPromise.allSettled([p1, p2, p3])\n  .then(results => console.log(results.length));",
      "options": [
        "3",
        "2",
        "1",
        "Error"
      ],
      "correctAnswer": 0,
      "explanation": "Promise.allSettled() waits for all promises regardless of outcome. Returns array with 3 results.",
      "hints": [
        "allSettled() waits for all promises",
        "Returns results for both fulfilled and rejected"
      ],
      "tags": [
        "promises",
        "allSettled",
        "async"
      ],
      "relatedConcepts": [
        "Promise.allSettled",
        "Promise handling",
        "Async patterns"
      ]
    },
    {
      "id": 61,
      "category": "prototypes",
      "difficulty": "intermediate",
      "type": "output",
      "title": "Prototype Chain Basic",
      "question": "What will be the output of the following code?",
      "code": "function Person(name) {\n  this.name = name;\n}\nPerson.prototype.greet = function() {\n  return 'Hello, ' + this.name;\n};\n\nconst alice = new Person('Alice');\nconsole.log(alice.greet());",
      "options": [
        "Hello, Alice",
        "Hello, undefined",
        "TypeError",
        "Hello, Person"
      ],
      "correctAnswer": 0,
      "explanation": "Constructor sets name property. Method on prototype is accessible to instances. this refers to alice.",
      "hints": [
        "Prototype methods are inherited by instances",
        "this refers to the instance"
      ],
      "tags": [
        "prototypes",
        "constructor",
        "inheritance"
      ],
      "relatedConcepts": [
        "Prototype chain",
        "Constructor functions",
        "Method inheritance"
      ]
    },
    {
      "id": 62,
      "category": "prototypes",
      "difficulty": "advanced",
      "type": "output",
      "title": "Prototype vs Own Property",
      "question": "What will be the output of the following code?",
      "code": "function Animal() {}\nAnimal.prototype.sound = 'generic';\n\nconst dog = new Animal();\ndog.sound = 'bark';\n\nconsole.log(dog.sound);\ndelete dog.sound;\nconsole.log(dog.sound);",
      "options": [
        "bark, generic",
        "generic, generic",
        "bark, undefined",
        "generic, bark"
      ],
      "correctAnswer": 0,
      "explanation": "Own property 'bark' shadows prototype property. After deletion, prototype property 'generic' is accessible.",
      "hints": [
        "Own properties shadow prototype properties",
        "delete removes own properties only"
      ],
      "tags": [
        "prototypes",
        "properties",
        "shadowing"
      ],
      "relatedConcepts": [
        "Property shadowing",
        "Own vs inherited properties",
        "Delete operator"
      ]
    },
    {
      "id": 63,
      "category": "closures",
      "difficulty": "advanced",
      "type": "output",
      "title": "Closure Memory Leak Prevention",
      "question": "What will be the output of the following code?",
      "code": "function createCounter() {\n  let count = 0;\n  return {\n    increment: () => ++count,\n    decrement: () => --count,\n    get: () => count\n  };\n}\n\nconst counter = createCounter();\nconsole.log(counter.increment());\nconsole.log(counter.get());",
      "options": [
        "1, 1",
        "0, 1",
        "1, 0",
        "undefined, undefined"
      ],
      "correctAnswer": 0,
      "explanation": "increment() increases count to 1 and returns it. get() returns current count value (1).",
      "hints": [
        "++count increments and returns new value",
        "All methods share the same count variable"
      ],
      "tags": [
        "closures",
        "encapsulation",
        "modules"
      ],
      "relatedConcepts": [
        "Closure patterns",
        "Data encapsulation",
        "Module pattern"
      ]
    },
    {
      "id": 64,
      "category": "error-handling",
      "difficulty": "intermediate",
      "type": "output",
      "title": "Error Types",
      "question": "What will be the output of the following code?",
      "code": "try {\n  nonExistentFunction();\n} catch (error) {\n  console.log(error.name);\n  console.log(error instanceof ReferenceError);\n}",
      "options": [
        "ReferenceError, true",
        "Error, false",
        "TypeError, false",
        "ReferenceError, false"
      ],
      "correctAnswer": 0,
      "explanation": "Calling undefined function throws ReferenceError. error.name is 'ReferenceError' and instanceof check is true.",
      "hints": [
        "Undefined functions throw ReferenceError",
        "instanceof checks error type"
      ],
      "tags": [
        "error-handling",
        "error-types",
        "instanceof"
      ],
      "relatedConcepts": [
        "Error types",
        "ReferenceError",
        "Error instanceof"
      ]
    },
    {
      "id": 65,
      "category": "performance",
      "difficulty": "intermediate",
      "type": "output",
      "title": "Object Property Access Performance",
      "question": "What will be the output of the following code?",
      "code": "const obj = { a: 1, b: 2, c: 3 };\nconst key = 'b';\n\nconsole.log(obj.b);\nconsole.log(obj[key]);\nconsole.log(obj['c']);",
      "options": [
        "2, 2, 3",
        "undefined, 2, 3",
        "2, undefined, 3",
        "b, b, c"
      ],
      "correctAnswer": 0,
      "explanation": "All three methods access object properties correctly. Dot notation, bracket with variable, bracket with string.",
      "hints": [
        "All property access methods work the same",
        "Brackets allow dynamic property names"
      ],
      "tags": [
        "performance",
        "objects",
        "properties"
      ],
      "relatedConcepts": [
        "Property access",
        "Object performance",
        "Dynamic properties"
      ]
    },
    {
      "id": 66,
      "category": "advanced",
      "difficulty": "advanced",
      "type": "output",
      "title": "Generator Functions",
      "question": "What will be the output of the following code?",
      "code": "function* counter() {\n  let i = 0;\n  while (i < 3) {\n    yield i++;\n  }\n}\n\nconst gen = counter();\nconsole.log(gen.next().value);\nconsole.log(gen.next().value);",
      "options": [
        "0, 1",
        "1, 2",
        "0, 0",
        "undefined, undefined"
      ],
      "correctAnswer": 0,
      "explanation": "Generator yields 0 (then increments to 1), next call yields 1 (then increments to 2).",
      "hints": [
        "yield returns current value",
        "i++ returns current value then increments"
      ],
      "tags": [
        "advanced",
        "generators",
        "yield"
      ],
      "relatedConcepts": [
        "Generator functions",
        "Yield keyword",
        "Iterator protocol"
      ]
    },
    {
      "id": 67,
      "category": "advanced",
      "difficulty": "advanced",
      "type": "output",
      "title": "Symbol and WeakMap",
      "question": "What will be the output of the following code?",
      "code": "const sym1 = Symbol('key');\nconst sym2 = Symbol('key');\nconst obj = {};\nobj[sym1] = 'value1';\nobj[sym2] = 'value2';\n\nconsole.log(obj[sym1]);\nconsole.log(sym1 === sym2);",
      "options": [
        "value1, false",
        "value2, false",
        "value1, true",
        "undefined, false"
      ],
      "correctAnswer": 0,
      "explanation": "Each Symbol() call creates unique symbol. obj[sym1] returns 'value1'. sym1 !== sym2 even with same description.",
      "hints": [
        "Each Symbol() creates unique value",
        "Symbols are always unique even with same description"
      ],
      "tags": [
        "advanced",
        "symbols",
        "unique"
      ],
      "relatedConcepts": [
        "Symbol primitives",
        "Symbol uniqueness",
        "Object keys"
      ]
    },
    {
      "id": 68,
      "category": "strings",
      "difficulty": "advanced",
      "type": "output",
      "title": "String PadStart and PadEnd",
      "question": "What will be the output of the following code?",
      "code": "const num = '5';\nconst padded = num.padStart(3, '0');\nconst result = padded.padEnd(5, 'X');\nconsole.log(result);",
      "options": [
        "005XX",
        "5000X",
        "00500",
        "005"
      ],
      "correctAnswer": 0,
      "explanation": "padStart(3, '0') makes '005' (length 3). padEnd(5, 'X') makes '005XX' (length 5).",
      "hints": [
        "padStart adds to beginning",
        "padEnd adds to end"
      ],
      "tags": [
        "strings",
        "padding",
        "methods"
      ],
      "relatedConcepts": [
        "String padding",
        "String methods",
        "ES2017 features"
      ]
    },
    {
      "id": 69,
      "category": "arrays",
      "difficulty": "advanced",
      "type": "output",
      "title": "Array From and Keys",
      "question": "What will be the output of the following code?",
      "code": "const arr = Array.from({ length: 3 }, (_, i) => i * 2);\nconst keys = Array.from(arr.keys());\nconsole.log(arr);\nconsole.log(keys);",
      "options": [
        "[0, 2, 4], [0, 1, 2]",
        "[0, 1, 2], [0, 2, 4]",
        "[2, 4, 6], [0, 1, 2]",
        "[0, 2, 4], [1, 2, 3]"
      ],
      "correctAnswer": 0,
      "explanation": "Array.from creates [0, 2, 4] using mapping function. keys() returns iterator of indices [0, 1, 2].",
      "hints": [
        "Array.from with mapper: (_, i) => i * 2",
        "keys() returns array indices"
      ],
      "tags": [
        "arrays",
        "Array.from",
        "keys"
      ],
      "relatedConcepts": [
        "Array.from",
        "Array keys",
        "Array creation"
      ]
    },
    {
      "id": 70,
      "category": "loops",
      "difficulty": "advanced",
      "type": "output",
      "title": "For-In vs For-Of",
      "question": "What will be the output of the following code?",
      "code": "const arr = ['a', 'b', 'c'];\narr.custom = 'custom';\n\nfor (let key in arr) {\n  console.log(key);\n}\nconsole.log('---');\nfor (let value of arr) {\n  console.log(value);\n}",
      "options": [
        "0, 1, 2, custom, ---, a, b, c",
        "a, b, c, custom, ---, 0, 1, 2",
        "0, 1, 2, ---, a, b, c",
        "a, b, c, ---, 0, 1, 2, custom"
      ],
      "correctAnswer": 0,
      "explanation": "for-in iterates over enumerable properties (indices + custom). for-of iterates over values only.",
      "hints": [
        "for-in gives property names/indices",
        "for-of gives values only"
      ],
      "tags": [
        "loops",
        "for-in",
        "for-of"
      ],
      "relatedConcepts": [
        "For-in loops",
        "For-of loops",
        "Enumerable properties"
      ]
    },
    {
      "id": 71,
      "category": "arrays",
      "difficulty": "intermediate",
      "type": "output",
      "title": "Array Some and Every",
      "question": "What will be the output of the following code?",
      "code": "const numbers = [2, 4, 6, 8, 10];\nconst allEven = numbers.every(n => n % 2 === 0);\nconst hasLarge = numbers.some(n => n > 8);\nconsole.log(allEven);\nconsole.log(hasLarge);",
      "options": [
        "true, true",
        "false, true",
        "true, false",
        "false, false"
      ],
      "correctAnswer": 0,
      "explanation": "every() returns true because all numbers are even. some() returns true because 10 > 8.",
      "hints": [
        "every() checks if ALL elements pass test",
        "some() checks if ANY element passes test"
      ],
      "tags": [
        "arrays",
        "every",
        "some",
        "testing"
      ],
      "relatedConcepts": [
        "Array testing methods",
        "Boolean logic",
        "Predicate functions"
      ]
    },
    {
      "id": 72,
      "category": "variables",
      "difficulty": "advanced",
      "type": "output",
      "title": "Variable Destructuring with Rest",
      "question": "What will be the output of the following code?",
      "code": "const [first, second, ...rest] = [1, 2, 3, 4, 5];\nconsole.log(first);\nconsole.log(rest);\nconsole.log(rest.length);",
      "options": [
        "1, [3, 4, 5], 3",
        "1, [2, 3, 4, 5], 4",
        "[1], [3, 4, 5], 3",
        "1, 3, 3"
      ],
      "correctAnswer": 0,
      "explanation": "Destructuring assigns first=1, second=2, rest gets remaining elements [3, 4, 5] with length 3.",
      "hints": [
        "Rest pattern collects remaining elements",
        "first gets 1, rest gets [3, 4, 5]"
      ],
      "tags": [
        "variables",
        "destructuring",
        "rest",
        "arrays"
      ],
      "relatedConcepts": [
        "Array destructuring",
        "Rest patterns",
        "ES6 features"
      ]
    },
    {
      "id": 73,
      "category": "functions",
      "difficulty": "advanced",
      "type": "output",
      "title": "Function Name Property",
      "question": "What will be the output of the following code?",
      "code": "function namedFunction() {}\nconst anonymous = function() {};\nconst arrow = () => {};\nconst method = { fn() {} };\n\nconsole.log(namedFunction.name);\nconsole.log(anonymous.name);\nconsole.log(arrow.name);\nconsole.log(method.fn.name);",
      "options": [
        "namedFunction, anonymous, arrow, fn",
        "namedFunction, , arrow, fn",
        "function, function, arrow, method",
        "namedFunction, undefined, arrow, undefined"
      ],
      "correctAnswer": 0,
      "explanation": "Function.name returns the function's name. Anonymous gets variable name, arrow gets variable name, method gets property name.",
      "hints": [
        "Function.name infers names from context",
        "Variable names are used for anonymous functions"
      ],
      "tags": [
        "functions",
        "name",
        "property"
      ],
      "relatedConcepts": [
        "Function name property",
        "Function inference",
        "ES6 features"
      ]
    },
    {
      "id": 74,
      "category": "objects",
      "difficulty": "advanced",
      "type": "output",
      "title": "Object Assign vs Spread",
      "question": "What will be the output of the following code?",
      "code": "const obj1 = { a: 1, b: 2 };\nconst obj2 = { b: 3, c: 4 };\nconst assigned = Object.assign({}, obj1, obj2);\nconst spread = { ...obj1, ...obj2 };\n\nconsole.log(assigned.b);\nconsole.log(spread.b);",
      "options": [
        "3, 3",
        "2, 2",
        "3, 2",
        "2, 3"
      ],
      "correctAnswer": 0,
      "explanation": "Both Object.assign and spread operator merge objects left to right. obj2.b (3) overwrites obj1.b (2).",
      "hints": [
        "Both methods merge left to right",
        "Later properties overwrite earlier ones"
      ],
      "tags": [
        "objects",
        "assign",
        "spread",
        "merging"
      ],
      "relatedConcepts": [
        "Object merging",
        "Object.assign",
        "Spread operator"
      ]
    },
    {
      "id": 75,
      "category": "promises",
      "difficulty": "advanced",
      "type": "output",
      "title": "Promise Race",
      "question": "What will be the output of the following code?",
      "code": "const fast = new Promise(resolve => setTimeout(() => resolve('fast'), 100));\nconst slow = new Promise(resolve => setTimeout(() => resolve('slow'), 200));\n\nPromise.race([slow, fast])\n  .then(result => console.log(result));\nconsole.log('immediate');",
      "options": [
        "immediate, fast",
        "immediate, slow",
        "fast, immediate",
        "slow, immediate"
      ],
      "correctAnswer": 0,
      "explanation": "Synchronous code runs first ('immediate'). Promise.race resolves with first completed promise ('fast' at 100ms).",
      "hints": [
        "Synchronous code runs before async",
        "race() resolves with first completed promise"
      ],
      "tags": [
        "promises",
        "race",
        "timing"
      ],
      "relatedConcepts": [
        "Promise.race",
        "Promise timing",
        "Asynchronous execution"
      ]
    },
    {
      "id": 76,
      "category": "es6",
      "difficulty": "intermediate",
      "type": "output",
      "title": "Map Object",
      "question": "What will be the output of the following code?",
      "code": "const map = new Map();\nmap.set('key1', 'value1');\nmap.set(42, 'value2');\nmap.set('key1', 'updated');\n\nconsole.log(map.size);\nconsole.log(map.get('key1'));",
      "options": [
        "2, updated",
        "3, value1",
        "2, value1",
        "3, updated"
      ],
      "correctAnswer": 0,
      "explanation": "Map has 2 unique keys. Setting 'key1' again updates its value to 'updated'.",
      "hints": [
        "Map stores unique keys",
        "Setting existing key updates its value"
      ],
      "tags": [
        "es6",
        "map",
        "data-structures"
      ],
      "relatedConcepts": [
        "Map object",
        "Key-value pairs",
        "ES6 collections"
      ]
    },
    {
      "id": 77,
      "category": "es6",
      "difficulty": "intermediate",
      "type": "output",
      "title": "Set Object",
      "question": "What will be the output of the following code?",
      "code": "const set = new Set([1, 2, 3, 3, 4, 4, 5]);\nset.add(6);\nset.add(3);\n\nconsole.log(set.size);\nconsole.log(set.has(3));",
      "options": [
        "6, true",
        "7, true",
        "6, false",
        "5, true"
      ],
      "correctAnswer": 0,
      "explanation": "Set removes duplicates: [1,2,3,4,5]. Adding 6 makes size 6. Adding 3 again doesn't change size.",
      "hints": [
        "Set automatically removes duplicates",
        "Adding existing value doesn't change size"
      ],
      "tags": [
        "es6",
        "set",
        "data-structures"
      ],
      "relatedConcepts": [
        "Set object",
        "Unique values",
        "ES6 collections"
      ]
    },
    {
      "id": 78,
      "category": "strings",
      "difficulty": "intermediate",
      "type": "output",
      "title": "String Replace with Regex",
      "question": "What will be the output of the following code?",
      "code": "const str = 'Hello World Hello';\nconst result1 = str.replace('Hello', 'Hi');\nconst result2 = str.replace(/Hello/g, 'Hi');\nconsole.log(result1);\nconsole.log(result2);",
      "options": [
        "Hi World Hello, Hi World Hi",
        "Hi World Hi, Hi World Hi",
        "Hello World Hello, Hi World Hi",
        "Hi World Hello, Hello World Hello"
      ],
      "correctAnswer": 0,
      "explanation": "replace() with string replaces only first occurrence. replace() with global regex (/g) replaces all occurrences.",
      "hints": [
        "String replace() replaces only first match",
        "Global regex (/g) replaces all matches"
      ],
      "tags": [
        "strings",
        "replace",
        "regex"
      ],
      "relatedConcepts": [
        "String replacement",
        "Regular expressions",
        "Global matching"
      ]
    },
    {
      "id": 79,
      "category": "operators",
      "difficulty": "advanced",
      "type": "output",
      "title": "Optional Chaining with Functions",
      "question": "What will be the output of the following code?",
      "code": "const obj = {\n  method: function() { return 'called'; }\n};\n\nconsole.log(obj.method?.());\nconsole.log(obj.missing?.());\nconsole.log(obj.missing?.().result);",
      "options": [
        "called, undefined, undefined",
        "called, TypeError, TypeError",
        "called, undefined, TypeError",
        "function, undefined, undefined"
      ],
      "correctAnswer": 0,
      "explanation": "Optional chaining (?.) safely calls methods. obj.method() returns 'called'. Missing methods return undefined.",
      "hints": [
        "?. safely calls methods if they exist",
        "Returns undefined for missing methods"
      ],
      "tags": [
        "operators",
        "optional-chaining",
        "methods"
      ],
      "relatedConcepts": [
        "Optional chaining",
        "Safe method calls",
        "ES2020 features"
      ]
    },
    {
      "id": 80,
      "category": "advanced",
      "difficulty": "advanced",
      "type": "output",
      "title": "WeakMap and Garbage Collection",
      "question": "What will be the output of the following code?",
      "code": "let obj = { name: 'test' };\nconst weakMap = new WeakMap();\nweakMap.set(obj, 'value');\n\nconsole.log(weakMap.has(obj));\nobj = null;\n// Garbage collection would happen here\nconsole.log(weakMap.size);",
      "options": [
        "true, undefined",
        "true, 0",
        "false, undefined",
        "true, 1"
      ],
      "correctAnswer": 0,
      "explanation": "WeakMap.has(obj) returns true. WeakMap.size is undefined because WeakMaps don't have a size property.",
      "hints": [
        "WeakMap holds weak references",
        "WeakMap doesn't have size property"
      ],
      "tags": [
        "advanced",
        "weakmap",
        "garbage-collection"
      ],
      "relatedConcepts": [
        "WeakMap",
        "Weak references",
        "Memory management"
      ]
    },
    {
      "id": 81,
      "category": "dom",
      "difficulty": "intermediate",
      "type": "concept",
      "title": "Event Delegation",
      "question": "What is event delegation and why is it useful?",
      "code": "document.getElementById('parent').addEventListener('click', function(e) {\n  if (e.target.classList.contains('child')) {\n    console.log('Child clicked');\n  }\n});",
      "options": [
        "Attaching one listener to parent to handle child events",
        "Delegating events to child elements",
        "Creating multiple event listeners",
        "Preventing event bubbling"
      ],
      "correctAnswer": 0,
      "explanation": "Event delegation uses event bubbling to handle events on child elements through a single parent listener.",
      "hints": [
        "Uses event bubbling",
        "Single listener handles multiple elements"
      ],
      "tags": [
        "dom",
        "events",
        "delegation"
      ],
      "relatedConcepts": [
        "Event bubbling",
        "Event handling",
        "DOM events"
      ]
    },
    {
      "id": 82,
      "category": "testing",
      "difficulty": "intermediate",
      "type": "concept",
      "title": "Test-Driven Development",
      "question": "What is the correct order in TDD?",
      "code": "// Example TDD cycle\nfunction add(a, b) {\n  return a + b;\n}\n\n// Test\nexpect(add(2, 3)).toBe(5);",
      "options": [
        "Red (fail) → Green (pass) → Refactor",
        "Green (pass) → Red (fail) → Refactor",
        "Write code → Test → Refactor",
        "Test → Refactor → Write code"
      ],
      "correctAnswer": 0,
      "explanation": "TDD follows Red-Green-Refactor: write failing test, make it pass, then refactor.",
      "hints": [
        "Write test first",
        "Make it pass",
        "Then improve"
      ],
      "tags": [
        "testing",
        "tdd",
        "methodology"
      ],
      "relatedConcepts": [
        "Test-driven development",
        "Testing methodology",
        "Code quality"
      ]
    },
    {
      "id": 83,
      "category": "performance",
      "difficulty": "advanced",
      "type": "concept",
      "title": "Debouncing vs Throttling",
      "question": "What's the difference between debouncing and throttling?",
      "code": "// Debounce\nfunction debounce(func, delay) {\n  let timeoutId;\n  return function(...args) {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => func.apply(this, args), delay);\n  };\n}\n\n// Throttle\nfunction throttle(func, delay) {\n  let lastCall = 0;\n  return function(...args) {\n    const now = Date.now();\n    if (now - lastCall >= delay) {\n      lastCall = now;\n      func.apply(this, args);\n    }\n  };\n}",
      "options": [
        "Debounce delays until quiet period, throttle limits frequency",
        "Debounce limits frequency, throttle delays until quiet",
        "Both do the same thing",
        "Debounce is for events, throttle is for functions"
      ],
      "correctAnswer": 0,
      "explanation": "Debouncing waits for a quiet period before executing. Throttling limits execution frequency.",
      "hints": [
        "Debounce = wait for quiet",
        "Throttle = limit frequency"
      ],
      "tags": [
        "performance",
        "debouncing",
        "throttling"
      ],
      "relatedConcepts": [
        "Performance optimization",
        "Event handling",
        "Rate limiting"
      ]
    },
    {
      "id": 84,
      "category": "modules",
      "difficulty": "intermediate",
      "type": "concept",
      "title": "ES6 Modules vs CommonJS",
      "question": "What's the main difference between ES6 modules and CommonJS?",
      "code": "// ES6 Modules\nimport { func } from './module.js';\nexport const myFunc = () => {};\n\n// CommonJS\nconst { func } = require('./module.js');\nmodule.exports = { myFunc: () => {} };",
      "options": [
        "ES6 is static, CommonJS is dynamic",
        "ES6 is dynamic, CommonJS is static",
        "No difference in functionality",
        "ES6 only works in browsers"
      ],
      "correctAnswer": 0,
      "explanation": "ES6 modules are statically analyzed at compile time. CommonJS is dynamically loaded at runtime.",
      "hints": [
        "Static vs dynamic loading",
        "Compile time vs runtime"
      ],
      "tags": [
        "modules",
        "es6",
        "commonjs"
      ],
      "relatedConcepts": [
        "Module systems",
        "Import/export",
        "Static analysis"
      ]
    },
    {
      "id": 85,
      "category": "async",
      "difficulty": "advanced",
      "type": "output",
      "title": "Async Iterator",
      "question": "What will be the output of the following code?",
      "code": "async function* asyncGenerator() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n\n(async () => {\n  for await (const value of asyncGenerator()) {\n    console.log(value);\n  }\n})();\nconsole.log('immediate');",
      "options": [
        "immediate, 1, 2, 3",
        "1, 2, 3, immediate",
        "immediate (then 1, 2, 3 asynchronously)",
        "1, immediate, 2, 3"
      ],
      "correctAnswer": 2,
      "explanation": "Synchronous code runs first ('immediate'), then async iteration happens asynchronously.",
      "hints": [
        "Synchronous runs first",
        "for await is asynchronous"
      ],
      "tags": [
        "async",
        "generators",
        "iteration"
      ],
      "relatedConcepts": [
        "Async generators",
        "Async iteration",
        "for await"
      ]
    },
    {
      "id": 86,
      "category": "security",
      "difficulty": "intermediate",
      "type": "concept",
      "title": "XSS Prevention",
      "question": "How can you prevent XSS attacks in JavaScript?",
      "code": "// Unsafe\nelement.innerHTML = userInput;\n\n// Safe\nelement.textContent = userInput;\n// or\nelement.innerHTML = DOMPurify.sanitize(userInput);",
      "options": [
        "Sanitize input and use textContent for plain text",
        "Use innerHTML for all content",
        "Trust all user input",
        "Only use eval() for user code"
      ],
      "correctAnswer": 0,
      "explanation": "Prevent XSS by sanitizing input and using textContent instead of innerHTML for plain text.",
      "hints": [
        "Sanitize user input",
        "textContent is safer than innerHTML"
      ],
      "tags": [
        "security",
        "xss",
        "sanitization"
      ],
      "relatedConcepts": [
        "Cross-site scripting",
        "Input sanitization",
        "Web security"
      ]
    },
    {
      "id": 87,
      "category": "patterns",
      "difficulty": "advanced",
      "type": "concept",
      "title": "Observer Pattern",
      "question": "What is the Observer pattern used for?",
      "code": "class Subject {\n  constructor() {\n    this.observers = [];\n  }\n  \n  subscribe(observer) {\n    this.observers.push(observer);\n  }\n  \n  notify(data) {\n    this.observers.forEach(observer => observer.update(data));\n  }\n}",
      "options": [
        "Notifying multiple objects about state changes",
        "Creating singleton instances",
        "Composing objects",
        "Abstracting object creation"
      ],
      "correctAnswer": 0,
      "explanation": "Observer pattern allows objects to be notified when another object's state changes.",
      "hints": [
        "Multiple objects get notified",
        "State change notifications"
      ],
      "tags": [
        "patterns",
        "observer",
        "design-patterns"
      ],
      "relatedConcepts": [
        "Design patterns",
        "Event handling",
        "Pub/sub pattern"
      ]
    },
    {
      "id": 88,
      "category": "memory",
      "difficulty": "advanced",
      "type": "concept",
      "title": "Memory Leaks",
      "question": "Which of these can cause memory leaks?",
      "code": "// Potential leak\nlet element = document.getElementById('button');\nelement.onclick = function() {\n  // element is captured in closure\n  console.log(element.id);\n};\n\n// Cleanup\nelement.onclick = null;\nelement = null;",
      "options": [
        "Circular references and forgotten event listeners",
        "Using let instead of var",
        "Creating too many functions",
        "Using arrow functions"
      ],
      "correctAnswer": 0,
      "explanation": "Memory leaks occur from circular references, uncleaned event listeners, and persistent closures.",
      "hints": [
        "Clean up event listeners",
        "Break circular references"
      ],
      "tags": [
        "memory",
        "leaks",
        "performance"
      ],
      "relatedConcepts": [
        "Memory management",
        "Garbage collection",
        "Performance"
      ]
    },
    {
      "id": 89,
      "category": "algorithms",
      "difficulty": "intermediate",
      "type": "output",
      "title": "Binary Search",
      "question": "What will be the output of this binary search?",
      "code": "function binarySearch(arr, target) {\n  let left = 0, right = arr.length - 1;\n  \n  while (left <= right) {\n    let mid = Math.floor((left + right) / 2);\n    if (arr[mid] === target) return mid;\n    if (arr[mid] < target) left = mid + 1;\n    else right = mid - 1;\n  }\n  return -1;\n}\n\nconsole.log(binarySearch([1, 3, 5, 7, 9], 5));\nconsole.log(binarySearch([1, 3, 5, 7, 9], 6));",
      "options": [
        "2, -1",
        "5, -1",
        "2, 6",
        "3, -1"
      ],
      "correctAnswer": 0,
      "explanation": "Binary search finds 5 at index 2, and returns -1 for 6 (not found).",
      "hints": [
        "Binary search returns index",
        "Returns -1 when not found"
      ],
      "tags": [
        "algorithms",
        "search",
        "binary-search"
      ],
      "relatedConcepts": [
        "Binary search",
        "Search algorithms",
        "Time complexity"
      ]
    },
    {
      "id": 90,
      "category": "data-structures",
      "difficulty": "intermediate",
      "type": "concept",
      "title": "Stack vs Queue",
      "question": "What's the difference between Stack and Queue?",
      "code": "// Stack (LIFO)\nconst stack = [];\nstack.push(1, 2, 3);\nconsole.log(stack.pop()); // 3\n\n// Queue (FIFO)\nconst queue = [];\nqueue.push(1, 2, 3);\nconsole.log(queue.shift()); // 1",
      "options": [
        "Stack is LIFO, Queue is FIFO",
        "Stack is FIFO, Queue is LIFO",
        "Both are LIFO",
        "Both are FIFO"
      ],
      "correctAnswer": 0,
      "explanation": "Stack follows Last In, First Out (LIFO). Queue follows First In, First Out (FIFO).",
      "hints": [
        "Stack = LIFO (Last In, First Out)",
        "Queue = FIFO (First In, First Out)"
      ],
      "tags": [
        "data-structures",
        "stack",
        "queue"
      ],
      "relatedConcepts": [
        "Data structures",
        "LIFO",
        "FIFO"
      ]
    },
    {
      "id": 91,
      "category": "regex",
      "difficulty": "intermediate",
      "type": "output",
      "title": "Regular Expression Matching",
      "question": "What will be the output of the following code?",
      "code": "const str = 'The price is $25.99';\nconst regex = /\\$([0-9]+\\.?[0-9]*)/;\nconst match = str.match(regex);\nconsole.log(match[0]);\nconsole.log(match[1]);",
      "options": [
        "$25.99, 25.99",
        "25.99, $25.99",
        "$25.99, $25.99",
        "25.99, 25.99"
      ],
      "correctAnswer": 0,
      "explanation": "match[0] is the full match ($25.99), match[1] is the first capture group (25.99).",
      "hints": [
        "match[0] = full match",
        "match[1] = first capture group"
      ],
      "tags": [
        "regex",
        "matching",
        "capture-groups"
      ],
      "relatedConcepts": [
        "Regular expressions",
        "Capture groups",
        "String matching"
      ]
    },
    {
      "id": 92,
      "category": "events",
      "difficulty": "intermediate",
      "type": "concept",
      "title": "Event Bubbling vs Capturing",
      "question": "What's the difference between event bubbling and capturing?",
      "code": "element.addEventListener('click', handler, false); // Bubbling\nelement.addEventListener('click', handler, true);  // Capturing",
      "options": [
        "Bubbling goes up, capturing goes down",
        "Capturing goes up, bubbling goes down",
        "They're the same thing",
        "Bubbling is faster than capturing"
      ],
      "correctAnswer": 0,
      "explanation": "Capturing phase goes down from document to target. Bubbling phase goes up from target to document.",
      "hints": [
        "Capturing = down the tree",
        "Bubbling = up the tree"
      ],
      "tags": [
        "events",
        "bubbling",
        "capturing"
      ],
      "relatedConcepts": [
        "Event phases",
        "DOM events",
        "Event propagation"
      ]
    },
    {
      "id": 93,
      "category": "timing",
      "difficulty": "advanced",
      "type": "output",
      "title": "SetTimeout Order",
      "question": "What will be the output of the following code?",
      "code": "console.log(1);\nsetTimeout(() => console.log(2), 0);\nPromise.resolve().then(() => console.log(3));\nconsole.log(4);",
      "options": [
        "1, 4, 3, 2",
        "1, 2, 3, 4",
        "1, 3, 4, 2",
        "1, 4, 2, 3"
      ],
      "correctAnswer": 0,
      "explanation": "Synchronous code runs first (1, 4), then microtasks like Promises (3), then macrotasks like setTimeout (2).",
      "hints": [
        "Synchronous first",
        "Microtasks before macrotasks"
      ],
      "tags": [
        "timing",
        "event-loop",
        "async"
      ],
      "relatedConcepts": [
        "Event loop",
        "Microtasks",
        "Macrotasks"
      ]
    },
    {
      "id": 94,
      "category": "inheritance",
      "difficulty": "advanced",
      "type": "output",
      "title": "Class Inheritance",
      "question": "What will be the output of the following code?",
      "code": "class Animal {\n  constructor(name) {\n    this.name = name;\n  }\n  speak() {\n    return `${this.name} makes a sound`;\n  }\n}\n\nclass Dog extends Animal {\n  speak() {\n    return `${super.speak()} - Woof!`;\n  }\n}\n\nconst dog = new Dog('Rex');\nconsole.log(dog.speak());",
      "options": [
        "Rex makes a sound - Woof!",
        "Rex - Woof!",
        "undefined makes a sound - Woof!",
        "Rex makes a sound"
      ],
      "correctAnswer": 0,
      "explanation": "super.speak() calls the parent class method, then concatenates with ' - Woof!'.",
      "hints": [
        "super calls parent method",
        "String concatenation"
      ],
      "tags": [
        "inheritance",
        "classes",
        "super"
      ],
      "relatedConcepts": [
        "Class inheritance",
        "Super keyword",
        "Method overriding"
      ]
    },
    {
      "id": 95,
      "category": "validation",
      "difficulty": "intermediate",
      "type": "concept",
      "title": "Type Checking",
      "question": "What's the best way to check if a value is an array?",
      "code": "const arr = [1, 2, 3];\n\n// Options:\ntypeof arr === 'array'        // 1\narr instanceof Array          // 2\nArray.isArray(arr)           // 3\narr.constructor === Array     // 4",
      "options": [
        "Array.isArray() is most reliable",
        "typeof is best for arrays",
        "instanceof is always correct",
        "constructor check is safest"
      ],
      "correctAnswer": 0,
      "explanation": "Array.isArray() is the most reliable method, works across different contexts and frames.",
      "hints": [
        "Array.isArray() is the standard method",
        "Works across different execution contexts"
      ],
      "tags": [
        "validation",
        "arrays",
        "type-checking"
      ],
      "relatedConcepts": [
        "Type checking",
        "Array detection",
        "JavaScript types"
      ]
    },
    {
      "id": 96,
      "category": "json",
      "difficulty": "intermediate",
      "type": "output",
      "title": "JSON Parsing",
      "question": "What will be the output of the following code?",
      "code": "const obj = { name: 'John', age: undefined, city: 'NYC' };\nconst json = JSON.stringify(obj);\nconst parsed = JSON.parse(json);\nconsole.log(parsed.age);\nconsole.log('age' in parsed);",
      "options": [
        "undefined, false",
        "undefined, true",
        "null, false",
        "null, true"
      ],
      "correctAnswer": 0,
      "explanation": "JSON.stringify ignores undefined properties. After parsing, 'age' property doesn't exist.",
      "hints": [
        "JSON.stringify ignores undefined",
        "Missing properties return undefined"
      ],
      "tags": [
        "json",
        "serialization",
        "parsing"
      ],
      "relatedConcepts": [
        "JSON serialization",
        "Undefined handling",
        "Object properties"
      ]
    },
    {
      "id": 97,
      "category": "conditionals",
      "difficulty": "intermediate",
      "type": "output",
      "title": "Ternary Operator Chain",
      "question": "What will be the output of the following code?",
      "code": "const score = 85;\nconst grade = score >= 90 ? 'A' : score >= 80 ? 'B' : score >= 70 ? 'C' : 'D';\nconsole.log(grade);",
      "options": [
        "B",
        "A",
        "C",
        "D"
      ],
      "correctAnswer": 0,
      "explanation": "Ternary operators are evaluated left to right. 85 >= 90 is false, 85 >= 80 is true, so returns 'B'.",
      "hints": [
        "Ternary chains evaluate left to right",
        "85 >= 80 is true"
      ],
      "tags": [
        "conditionals",
        "ternary",
        "operators"
      ],
      "relatedConcepts": [
        "Ternary operator",
        "Conditional logic",
        "Operator precedence"
      ]
    },
    {
      "id": 98,
      "category": "bitwise",
      "difficulty": "advanced",
      "type": "output",
      "title": "Bitwise Operations",
      "question": "What will be the output of the following code?",
      "code": "console.log(5 & 3);\nconsole.log(5 | 3);\nconsole.log(5 ^ 3);",
      "options": [
        "1, 7, 6",
        "3, 5, 2",
        "2, 6, 4",
        "0, 8, 8"
      ],
      "correctAnswer": 0,
      "explanation": "5 & 3 = 1 (101 & 011 = 001), 5 | 3 = 7 (101 | 011 = 111), 5 ^ 3 = 6 (101 ^ 011 = 110).",
      "hints": [
        "& = AND",
        "| = OR",
        "^ = XOR"
      ],
      "tags": [
        "bitwise",
        "operators",
        "binary"
      ],
      "relatedConcepts": [
        "Bitwise operations",
        "Binary arithmetic",
        "Logical operators"
      ]
    },
    {
      "id": 99,
      "category": "scope",
      "difficulty": "advanced",
      "type": "output",
      "title": "Block Scope with Loops",
      "question": "What will be the output of the following code?",
      "code": "for (let i = 0; i < 3; i++) {\n  setTimeout(() => console.log('let:', i), 0);\n}\n\nfor (var j = 0; j < 3; j++) {\n  setTimeout(() => console.log('var:', j), 0);\n}",
      "options": [
        "let: 0, 1, 2 and var: 3, 3, 3",
        "let: 3, 3, 3 and var: 0, 1, 2",
        "let: 0, 1, 2 and var: 0, 1, 2",
        "let: 3, 3, 3 and var: 3, 3, 3"
      ],
      "correctAnswer": 0,
      "explanation": "let creates block scope, each iteration has its own i. var is function-scoped, all callbacks see final value.",
      "hints": [
        "let creates new scope each iteration",
        "var shares scope across iterations"
      ],
      "tags": [
        "scope",
        "loops",
        "closures"
      ],
      "relatedConcepts": [
        "Block scope",
        "Function scope",
        "Closure capture"
      ]
    },
    {
      "id": 100,
      "category": "meta",
      "difficulty": "beginner",
      "type": "concept",
      "title": "JavaScript Engine",
      "question": "What does the JavaScript engine do?",
      "code": "// JavaScript Engine Process:\n// 1. Parse code into AST\n// 2. Compile to bytecode\n// 3. Execute bytecode\n// 4. Optimize hot code paths",
      "options": [
        "Parses, compiles, and executes JavaScript code",
        "Only interprets JavaScript line by line",
        "Only compiles JavaScript to machine code",
        "Only handles DOM manipulation"
      ],
      "correctAnswer": 0,
      "explanation": "Modern JavaScript engines parse code into AST, compile to bytecode, execute it, and optimize frequently used code.",
      "hints": [
        "Modern engines use JIT compilation",
        "Parse → Compile → Execute → Optimize"
      ],
      "tags": [
        "meta",
        "engine",
        "compilation"
      ],
      "relatedConcepts": [
        "JavaScript engine",
        "JIT compilation",
        "Code optimization"
      ]
    }
  ]
}